<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:exsl="http://exslt.org/common" >
<xsl:output method="text" media-type="text/plain" />

<xsl:variable name="sql" select="document(concat(/build/for/@dialect,'/sql.xml'))" />
<xsl:variable name="types" select="document(concat(/build/for/@dialect,'/types.xml'))" />
<xsl:variable name="schemadoc" select="document(/build/for/@schema)" />
<xsl:variable name="procschema">
    <xsl:apply-templates select="$schemadoc/schema" mode="expand" />
</xsl:variable>
<xsl:variable name="schema" select="exsl:node-set($procschema)" />

<xsl:template match="/">
    <xsl:apply-templates select="/build/for/target" />
</xsl:template>

<xsl:template match="target[@name='create-all']">
    <xsl:apply-templates select="$schema/schema/table" />
</xsl:template>

<xsl:template match="table">
    <xsl:apply-templates select="$sql/dml/create-table/*" mode="template" >
        <xsl:with-param name="data" select="." />
    </xsl:apply-templates>
    <xsl:text>&#xa;&#xa;</xsl:text>
</xsl:template>

<!--mode:expand
This section specifies templates that preprocess and expand the data in the raw schema
to produce a full specification of the schema.
-->

<xsl:template match="@*" mode="expand" >
    <xsl:attribute name="{name()}">
        <xsl:value-of select="." />
    </xsl:attribute>
</xsl:template>

<xsl:template match="schema" mode="expand" >
    <xsl:element name="schema">
        <xsl:apply-templates select="@*" mode="expand" />
        <xsl:apply-templates select="*" mode="expand" />
    </xsl:element>
</xsl:template>

<xsl:template match="table" mode="expand" >
    <xsl:element name="table">
        <xsl:apply-templates select="@*" mode="expand" />
        <xsl:apply-templates select="*" mode="expand" />
    </xsl:element>
</xsl:template>

<xsl:template match="column" mode="expand" >
    <xsl:element name="column">
        <xsl:apply-templates select="@*" mode="expand" />
    </xsl:element>
</xsl:template>

<xsl:template match="foreign-key" mode="expand" >
    <xsl:element name="foreign-key">
        <xsl:apply-templates select="@*" mode="expand" />
        <xsl:apply-templates select="*" mode="expand" />
    </xsl:element>
    <xsl:call-template name="foreign-key-get-columns" />
</xsl:template>

<xsl:template name="foreign-key-get-columns">
    <xsl:variable name="pschema" select="./../.." />
    <xsl:variable name="null" select="@null" />
    <xsl:variable name="fktablename" select="@table" />
    <xsl:variable name="fktable" select="$pschema/table[@name=$fktablename]" />
    <xsl:variable name="rspkcolumns">
        <xsl:for-each select="$fktable">
            <xsl:call-template name="table-get-pk-columns" />
        </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="pkcolumns" select="exsl:node-set($rspkcolumns)" />
    <xsl:variable name="prefix" select="$fktablename" />
    <xsl:for-each select="$pkcolumns/column">
        <column name="{concat($prefix,'_',@name)}" type="{@type}" null="{$null}" />
    </xsl:for-each>
</xsl:template>

<xsl:template name="table-get-pk-columns">
    <xsl:for-each select="column[@primary-key='true']">
        <column name="{@name}" type="{@type}" />
    </xsl:for-each>
</xsl:template>

<!--mode:template
This section specifies templates that apply to text template constructs
-->
<xsl:template match="text" mode="template" >
    <xsl:param name="data" />
    <xsl:message>text</xsl:message>
    <xsl:apply-templates mode="substitute" >
        <xsl:with-param name="data" select="$data" />
    </xsl:apply-templates>
</xsl:template>

<xsl:template match="each-column" mode="template" >
    <xsl:param name="data" />
    <xsl:variable name="temp" select="./*" />
    <xsl:variable name="separator" select="@separator" />
    <xsl:for-each select="$data/column">
        <xsl:apply-templates select="$temp" mode="template" >
            <xsl:with-param name="data" select="." />
        </xsl:apply-templates>
        <xsl:if test="following-sibling::*">
            <xsl:value-of select="$separator" />
        </xsl:if>
    </xsl:for-each>
</xsl:template>

<!--mode:substitute
This section declares templates that apply to text content that should be sent
to the output with posible substitutions.
-->
<xsl:template match="name" mode="substitute" >
    <xsl:param name="data" />
    <xsl:variable name="sust" select="name()" />
    <xsl:value-of select="$data/@*[name()=$sust]" />
</xsl:template>

<xsl:template match="type" mode="substitute" >
    <xsl:param name="data" />
    <xsl:variable name="typename" select="$data/@type" />
    <xsl:choose>
        <xsl:when test="$types/types/type[name()=$typename]/not-supported">
            <xsl:message terminate="yes">
                Type not supported by selected dialect
            </xsl:message>
        </xsl:when>
        <xsl:otherwise>
            <xsl:value-of select="$types/types/type[@name=$typename]/expands/@name" />
        </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="$data/@length">
        <xsl:value-of select="concat('(',$data/@length,')')" />
    </xsl:if>
</xsl:template>

<xsl:template match="null" mode="substitute" >
    <xsl:param name="data" />
    <xsl:choose>
        <xsl:when test="$data/@null='false'">
            <xsl:text>not null</xsl:text>
        </xsl:when>
        <xsl:otherwise>
            <xsl:text>null</xsl:text>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>

<xsl:template match="text()" mode="substitute" >
    <xsl:value-of select="." />
</xsl:template>
</xsl:stylesheet>
